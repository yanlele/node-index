## 合并数据流

在RxJS的世界中，为了满⾜复杂的需求，往往需要把不同来源的数据汇聚在⼀起，
把来⾃多个Observable对象的数据合并到⼀个Observable对象中，这就是本章介绍的内容。

功能需求 | 使用的操作符
:- | :-
把多个数据流以收尾相连接的方式合并 | concat / concatAll
把多个数据流中数据以先到先得的方式合并 | merge / mergeAll
把过个数据流中数据以一一对应的方式合并 | zip / zipAll
持续合并多个数据流中最新产生的数据 | combineLatest / combineAll / withLatestFrom
从多个数据流中选择第一个产生内容的数据流 | race
在数据流前面添加一个指定的数据 | startWith
只获取多个数据流最后产生的那个数据 | forkJoin
从告诫数据流中切换数据源 | switch / exhaust

### 合并类操作符

#### concat
按照顺序，前⼀个 observable 完成了再订阅下⼀个 observable 并发出值.                      

- 你可以把 concat 想象成 ATM 机前的⻓队，下⼀次交易 (subscription)不能在前⼀个交易完成前开始！
- 如果产⽣值的顺序不是⾸要考虑的，那么试试⽤ merge 来代替！

```typescript
/**
 * 最基本的使用
 *
 * 下面这种方式是作为 静态方法的实现，
 * 在RXJS5 版本的时候， 是可以通过实例方法实现concat的， 但是到了6 版本就取消了
 * 实例方法就是这样的 sourceOne$.concat(sourceTwo$); 这种方式在6版本取消了
 * 六版本只允许静态方法的方式创建合并
 */
import { concat, interval, of } from 'rxjs';
import { delay } from 'rxjs/operators';

const sourceOne$ = of(1, 2, 3);
const sourceTwo$ = of(4, 5, 6);
const example$ = concat(sourceOne$, sourceTwo$);

example$.subscribe(value => console.log(value));


/**
 * 使⽤延迟的 source observable 进⾏ concat
 */
// 延迟3秒发出
const sourceThree$ = sourceOne$.pipe(delay(3000));
// sourceTwo$ 要等待 sourceOne$ 完成之后才能订阅
const example2$ = concat(sourceThree$, sourceTwo$);
example2$.subscribe(value => console.log('Example: Delayed source one : ', value));


/**
 * 使⽤不完成的 source observable 进⾏ concat
 */
const source3$ = concat(
  interval(1000),
  of('this', 'never', 'runs')
);
source3$.subscribe(value => console.log('Example: Source never completes, second observable never runs: ', value));
```

#### merge

- merge会第⼀时间订阅所有的上游Observable，然后对上游的数据采取“先到先得”的策略，
任何⼀个Observable只要有数据推下来，就⽴刻转给下游Observable对象。
- 如果某个上游Observable对象不能完结，并不影响其他Observable对象的数据传给merge的下游。
- merge只有在所有的上游Observable都完结的时候，才会完结⾃⼰产⽣的Observable对象
- 如果产⽣值的顺序是⾸要考虑的，那么试试⽤ concat 来代替！


基本使用:                       
```typescript
/**
 * 基本使用
 */
import { interval, merge } from 'rxjs';
import { mapTo } from 'rxjs/operators';

const first$ = interval(2500);
const second$ = interval(2000);
const third$ = interval(1500);
const fourth$ = interval(1000);

// 从一个observable中发出输出值
const example$ = merge(
  first$.pipe(mapTo('first!')),
  second$.pipe(mapTo('second!')),
  third$.pipe(mapTo('third!')),
  fourth$.pipe(mapTo('fourth!')),
);

example$.subscribe(value => console.log(value));
```

merge可以有⼀个可选参数concurrent，⽤于指定可以同时合并的Observable对象个数

假设现在有3个Observable对象，⽽concurrent参数的值为2，如下⾯的              
代码所⽰：
```typescript
import { merge, timer } from 'rxjs';
import { map } from 'rxjs/operators';

const source1$ = timer(0, 1000).pipe(map(x => x + 'A'));
const source2$ = timer(500, 1000).pipe(map(x => x + 'B'));
const source3$ = timer(1000, 1000).pipe(map(x => x + 'C'));

// source3$中的数据永远不会获得进⼊merged$的机会，因为 merge最后⼀个参数是2，也就限定了同时只能同步合并两个Observable对象的数据，
const merged$ = merge(source1$, source2$, source3$, 2);

merged$.subscribe(value => console.log(value));
```


**使用场景**                            
我们知道fromEvent可以从⽹页中获取事件，只可惜，fromEvent⼀次
只能从⼀个DOM元素获取⼀种类型的事件。⽐如，我们关⼼某个元素的
click事件，同时也关⼼这个元素上的touchend事件，因为在移动设备上
touchend事件出现得⽐click更早，这两个事件的处理是⼀模⼀样的，但是
fromEvent不能同时获得两个事件的数据流，这时候就要借助merge的⼒量
了，代码如下：
```typescript
import { fromEvent, merge } from 'rxjs';

const click$ = fromEvent(document, 'click');
const touchend$ = fromEvent(document, 'touchend');
const merged$ = merge(click$, touchend$);

merged$.subscribe(value => console.log(value));
```

#### zip

拉链式组合                               

拉链合并两条链齿的关键，就是链齿必须⼀⼀
对应，这也是zip这个操作符的⼯作⽅式。zip就像是⼀个拉条，上游的
Observable对象就像是拉链的链齿，通过拉条合并，数据⼀定是⼀⼀对应的。

zip 操作符会订阅所有内部 observables，然后等待每个发出⼀个值。
⼀旦发⽣这种情况，将发出具有相应索引的所有值。
这会持续进⾏，直到⾄少⼀个内部 observable 完成。                      

demo0: 非常简单的一个例子
```typescript
import { of, zip } from 'rxjs';

const source1$ = of(1, 2, 3);
const source2$ = of('a', 'b', 'c');
const zipped$ = zip(source1$, source2$);

zipped$.subscribe(value => console.log(value));
```

demo1: 以交替的时间间隔对多个 observables 进⾏ zip          
```typescript
/**
 * 以交替的时间间隔对多个 observables 进⾏ zip
 */
import { of, zip } from 'rxjs';
import { delay } from 'rxjs/operators';

const sourceOne$ = of('hello');
const sourceTwo$ = of('world!');
const sourceThree$ = of('GoodBye');
const sourceFour$ = of('world!');

const example$ = zip(
  sourceOne$,
  sourceTwo$.pipe(delay(1000)),
  sourceThree$.pipe(delay(2000)),
  sourceFour$.pipe(delay(3000)),
);

example$.subscribe(value => console.log(value));
// [ 'hello', 'world!', 'GoodBye', 'world!' ]
```

demo2: 当⼀个 observable 完成时进⾏ zip
```typescript
/**
 * 当⼀个 observable 完成时进⾏ zip
 */
import { interval, zip } from 'rxjs';
import { take } from 'rxjs/operators';

const interval$ = interval(1000);
const example$ = zip(
  interval$,
  interval$.pipe(take(2))
);
example$.subscribe(value => console.log(value));
// [ 0, 0 ]
// [ 1, 1 ]
```



#### combineLatest
combineLatest合并数据流的⽅式是当任何⼀个上游Observable产⽣数据
时，从所有输⼊Observable对象中拿最后⼀次产⽣的数据（最新数据），
然后把这些数据组合起来传给下游。

combineLatest可能会反复使⽤上游产⽣的最新数据，只要上游不产⽣新的数据，那
combineLatest就会反复使⽤这个上游最后⼀次产⽣的数据

demo1:
```typescript
import { combineLatest, timer } from 'rxjs';

const source1$ = timer(500, 1000);
const source2$ = timer(1000, 1000);
const resource$ = combineLatest(source1$, source2$);

resource$.subscribe(value => console.log(value));
```
输出结果：           
```
[ 0, 0 ]
[ 1, 0 ]
[ 1, 1 ]
[ 2, 1 ]
[ 2, 2 ]
[ 3, 2 ]
```

每个数组中元素的个数和上游Observable数量相同，每个元素的下标和对应数
据源在combineLatest中的参数位置⼀致。

第⼀个数组元素来⾃于调⽤了
combineLatest的Observable对象，第⼆个元素来⾃于combineLatest的第⼀个参数；

![05-01](./image/05-01.png)                             


让source2$只吐出⼀个数据就完结，可以
看到combineLatest对单个上游Observable完结的处理，代码如下:               
```typescript
import { combineLatest, of, timer } from 'rxjs';

const source1$ = timer(500, 1000);
const source2$ = of('a');
const result$ = combineLatest(source1$, source2$);

result$.subscribe(value => console.log(value));
```
结果：             
```
[ 0, 'a' ]
[ 1, 'a' ]
[ 2, 'a' ]
[ 3, 'a' ]
......
```

上⾯的代码例⼦中，上游都有包含异步产⽣数据的Observable对象，
如果上游全部都是同步产⽣数据的Observable对象会怎样呢？结果可能会
和你想象的不⼤⼀样
```typescript
import { combineLatest, of } from 'rxjs';

const source1$ = of('a', 'b', 'c');
const source2$ = of(1, 2, 3);
const result$ = combineLatest(source1$, source2$);

result$.subscribe(value => console.log(value));
```
结果：             
```
[ 'c', 1 ]
[ 'c', 2 ]
[ 'c', 3 ]
```
这是由combineLatest的⼯作⽅式决定的。combineLatest会顺序订阅所
有上游的Observable对象，只有所有上游Observable对象都已经吐出数据
了，才会给下游传递所有上游“最新数据”组合的数据。


下⾯是合并三个of产⽣的Observable对象的代码:                
```typescript
import { combineLatest, of } from 'rxjs';

const source1$ = of('a', 'b', 'c');
const source2$ = of(1,2,3);
const source3$ = of('x', 'y');
const result$ = combineLatest(source1$, source2$, source3$);

result$.subscribe(value => console.log(value));
```
结果:             
```
[ 'c', 3, 'x' ]
[ 'c', 3, 'y' ]
```


**combineLatest: 1、定制下游数据**
如果`combineLatest`的输⼊只有`Observable`对象，那么传递给下游的数据
就是⼀个包含所有上游“最新数据”的数组，但是，有时候这样并不⽅便，
我们可能希望下游接收到的不是数组⽽是已经被真正“组合”过的数据。这
时候，可以利⽤`combineLatest`的⼀个可选参数`project`

combineLatest的最后⼀个参数可以是⼀个函数，这⾥我们称之为
project，project的作⽤是让combineLatest把所有上游的“最新数据”扔给下游
之前做⼀下组合处理。

project可以包含多个参数，每⼀个参数对应的是上游Observable的最新数据，project返回的结果就是combineLatest塞给下游的结果。                  
```typescript
import { combineLatest, timer } from 'rxjs';
import { map } from 'rxjs/operators';

const source1$ = timer(500, 1000);
const source2$ = timer(1000, 1000);
const project = (a, b) => `${a} and ${b}`;

const result$ = combineLatest(source1$, source2$, project);
result$.subscribe(value => console.log(value));

/* ==============================  map 操作符号的场景 - Start ============================== */
const result2$ = combineLatest(source1$, source2$)
  .pipe(map(arr => project(...arr)));
result2$.subscribe(value => console.log(value));  // 输出结果跟上面一模一样

/* ==============================  map 操作符号的场景 - End   ============================== */

```
结果：                 
```
0 and 0
1 and 0
1 and 1
2 and 1
2 and 2
3 and 2
3 and 3
......
```

**combineLatest: 2、多重依赖**
combineLatest产⽣的Observable对象数据依赖于上游的多个Observable
对象，如果上游的多个Observable对象又共同依赖于另⼀个Observable对
象，这就是多重（chong第2声）依赖问题

```typescript
import { combineLatest, timer } from 'rxjs';
import { map } from 'rxjs/operators';

const original$ = timer(0, 1000);
const source1$ = original$.pipe(map(x => x + ' a'));
const source2$ = original$.pipe(map(x => x + ' b'));
const result$ = combineLatest(source1$, source2$);

result$.subscribe(value => console.log(value));
```
看这段程序会有什么样的执⾏结果，程序启动的时候就会输出如下⼀⾏：                    
```
[ '0a', 0b' ]
```

接着，1秒钟之后，程序接着会输出下⾯两⾏：
```
[ '1a', '0b' ]
[ '1a', '1b' ]
```

然后，又过了1秒钟，程序又会输出下⾯两⾏：
```
[ '2a', '1b' ]
[ '2a', '2b' ]
```

程序的输出不会结束，整个数据管道都由original$驱动，⽽original$每⼀秒钟只产⽣⼀个数据，
但是在combineLatest之后却产⽣了两个数据。

直观上来说，当original$吐出数据1的时候，source1$会吐出1a，
source2$会吐出1b，那么result$就会产⽣这样⼀个输出:                  
```
[ '1a', '1b' ]
```

这种现象称为⼩缺陷（glitch），指的是combineLatest这样的操作符输
出的不⼀致情况，glitch发⽣是因为多个上游Observable“同时”吐出⼀个数
据，当然，并不是真正的“同时”，⼏个事件之间可能会间隔⼏纳秒的时
间，但是因为它们是由同⼀个数据源（在上⾯的例⼦中就是original$）引
发的，所以逻辑上算是"同时".

这种glitch现象被认为是RxJS的⼀个缺陷，函数响应式编程的原教旨主
义由此认定RxJS不能算是真正的函数响应式编程.

如果想要有上⾯那样纯正的
输出，我们只不过⽤错了操作符，这就需要引⼊RxJS中combineLatest的另
⼀个兄弟`withLatestFrom`。


**combineLatest: 03、其他例子**

combineLatest - 组合3个定时发送:                   
```typescript
import { combineLatest, timer } from 'rxjs';

const timerOne$ = timer(1000, 4000);
const timerTwo$ = timer(2000, 4000);
const timerThree$ = timer(3000, 4000);

const combined$ = combineLatest(timerOne$, timerTwo$, timerThree$);

combined$.subscribe(latestValues => {
  const [one, two, three] = latestValues;

  console.log(`
    timer one latest: ${one};
    timer two latest: ${two};
    timer three latest: ${three};
  `);
});
```
结果:                 
```
timer one latest: 0;
timer two latest: 0;
timer three latest: 0;


timer one latest: 1;
timer two latest: 0;
timer three latest: 0;


timer one latest: 1;
timer two latest: 1;
timer three latest: 0;


timer one latest: 1;
timer two latest: 1;
timer three latest: 1;


timer one latest: 2;
timer two latest: 1;
timer three latest: 1;


timer one latest: 2;
timer two latest: 2;
timer three latest: 1;


timer one latest: 2;
timer two latest: 2;
timer three latest: 2;
............
```


使⽤ projection:                  
```typescript
import { combineLatest, timer } from 'rxjs';

const timerOne$ = timer(1000, 4000);
const timerTwo$ = timer(2000, 4000);
const timerThree$ = timer(3000, 4000);

const combined$ = combineLatest(
  timerOne$,
  timerTwo$,
  timerThree$,
  (one, two, three) => {
    return `Timer One (Proj) Latest: ${one},
            Timer Two (Proj) Latest: ${two},
            Timer Three (Proj) Latest: ${three}
            `;
  }
);

combined$.subscribe(value => console.log(value));
```


组合两个按钮事件：               

TS:
```typescript
import { combineLatest, fromEvent } from 'rxjs';
import { map, mapTo, scan, startWith, tap } from 'rxjs/operators';

const setHtml = id => value => document.getElementById(id).innerHTML = value;

const addOneClick$ = id => fromEvent(document.getElementById(id), 'click')
  .pipe(
    mapTo(1),
    startWith(0),
    scan((acc, curr) => acc + curr),
    tap(setHtml(`${id}ToTal`)),
  );

const combineTotal$ = combineLatest(
  addOneClick$('red'),
  addOneClick$('black'),
).pipe(
  map(([value1, value2]) => value1 + value2),
);

combineTotal$.subscribe(setHtml('total'));
```
html：                   
```html
<div>
    <button id="red">Red</button>
    <button id="black">Black</button>
</div>
<div>Red： <span id="redTotal"></span></div>
<div>Black： <span id="blackTotal"></span></div>
<div>Total： <span id="total"></span></div>
```


#### withLatestFrom
Combines the source Observable with other Observables to create an Observable whose
 values are calculated from the latest values of each, only when the source emits.
```typescript
import { fromEvent, interval } from 'rxjs';
import { withLatestFrom } from 'rxjs/operators';

const clicks = fromEvent(document, 'click');
const timer = interval(1000);
const result = clicks.pipe(withLatestFrom(timer));
result.subscribe(x => console.log(x));
```

再举一个例子：              
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script src="https://unpkg.com/rxjs/bundles/rxjs.umd.min.js"></script>
    <title>产⽣glitch的⽹页应⽤例⼦</title>
    <style type="text/css">
        html, body {
            width: 100%;
            height: 100%;
            min-height: 100%;
        }
    </style>
</head>
<body>
<div>
    <div id="text"></div>
</div>

<script>
  const { fromEvent } = rxjs;
  const { withLatestFrom, map } = rxjs.operators;

  const event$ = fromEvent(document.body, 'click');
  const x$ = event$.pipe(map(e => e.x));
  const y$ = event$.pipe(map(e => e.y));

  const result$ = event$.pipe(
    withLatestFrom(x$, y$, (_, x, y) => `x: ${x}, y: ${y}`),
  );

  result$.subscribe(location => {
    console.log('#render: ', location);
    document.querySelector('#text').innerHTML = location;
  });

</script>
</body>
</html>
```


**进入正题**                            
```typescript
import { timer } from 'rxjs';
import { map, withLatestFrom } from 'rxjs/operators';

const source1$ = timer(0, 2000);
const source2$ = timer(500, 1000);

const result$ = source1$.pipe(
  map(x => 100 * x),
  withLatestFrom(source2$, (a, b) => a + b)
);

result$.subscribe(value => console.log(value));
```

result$由source1$调⽤withLatestFrom产⽣，第⼀个参数是source2$，这
样source2$的数据会是result$的⼀个输⼊。
注意，withLatestFrom第⼆个函数，功能和zip以及combineLatest的可选参数⼀样，⽤于定制产⽣的数据对
象形式。在这⾥，我们把source1$和source2$产⽣的数据相加，可以⽅便展⽰。

产⽣下游数据流result$中数据的步骤如下：                                     
1）在第0毫秒时刻，source1$吐出数据100，source2$没有吐出数据，所以没有给下游产⽣数据。                                       
2）在第500毫秒时刻，source2$吐出数据0，但是source2$并不直接触发给下游传递数据，所以依然没有给下游产⽣产⽣数据。                                      
3）在第1500毫秒时刻，source2$吐出数据1，同样不会给下游产⽣数据。                                     
4）在第2000毫秒时刻，source1$吐出数据100，这个数据会加上source2$吐出的最后⼀个数据1，产⽣传给下游的数据101。                                        
5）在第2500毫秒时刻，source2$吐出数据2，不会给下游产⽣数据。                                       
6）在第3500毫秒时刻，source2$吐出数据3，不会给下游产⽣数据。                                       
7）在第4000毫秒时刻，source1$吐出数据200，这个数据加上source2$吐出的最后⼀个数据3，产⽣传给下游的的数据203。                                        

`简单通俗点儿讲： 上面的例子中， 在source1$ 作用的操作符号， 
就是在 source1$ 数据源来到的时候， 处理拿到 source2$ 对应的最新数据。**更新节奏是根据source1$ 来的。**
`

上⾯程序的输出结果如下，每隔2秒钟输出⼀⾏：
```
101
203
305
407
509
```


**解决glitch**

如果我们⽤withLatestFrom，那么对应的多重依赖问题可以得到解决，因为产⽣的下游
Observable对象中数据⽣成节奏只由⼀个输⼊Observable对象决定。

```typescript
import { timer } from 'rxjs';
import { map, withLatestFrom } from 'rxjs/operators';

const original$ = timer(0, 1000);
const source1$ = original$.pipe(map(x => x + 'a'));
const source2$ = original$.pipe(map(x => x + 'b'));

const result$ = source1$.pipe(
  withLatestFrom(source2$)
);

result$.subscribe(value => console.log(value));
```

执行结果：               
```
[ '0a', '0b' ]
[ '1a', '1b' ]
[ '2a', '2b' ]
[ '3a', '3b' ]
[ '4a', '4b' ]
```

再看一个例子：                             
下面这个例子中 x$ 和 y$ 都是依赖 event$ 产生的, 所以任意选出一个作为数据控制源，就可以了。                  
```
/*
<style type="text/css">
  html, body {
  width: 100%;
  height: 100%;
  min-height: 100%;
}
</style>
<body>
<div>
  <div id="text"></div>
  </div>
</div>
*/

import { fromEvent } from 'rxjs';
import { map, withLatestFrom } from 'rxjs/operators';

const event$ = fromEvent(document.body, 'click');
const y$ = event$.pipe(map((e: MouseEvent) => e.y));
const x$ = event$.pipe(map((e: MouseEvent) => e.x));
const result$ = x$.pipe(withLatestFrom(y$, (x, y) => `x: ${x}, y: ${y}`));
result$.subscribe(value => {
  console.log('#render: ', value);
  document.querySelector('#text').innerHTML = value;
});
```

例子：withLatestFrom - 发出频率更快的第⼆个 source 的最新值
```typescript
import { interval } from 'rxjs';
import { map, withLatestFrom } from 'rxjs/operators';

const secondSource$ = interval(1000);
const source$ = interval(5000);
const example$ = source$.pipe(
  withLatestFrom(secondSource$),
  map(([first, second]) => {
    return `First Source 5s: ${first}; Second Source 1s: ${second}`
  }),
);
example$.subscribe(value => {console.log(value)});

/*
结果：
First Source 5s: 0; Second Source 1s: 3
First Source 5s: 1; Second Source 1s: 8
First Source 5s: 2; Second Source 1s: 13
* */
```

例子：withLatestFrom - 第⼆个 source 发出频率更慢⼀些                 
```typescript
import { interval } from 'rxjs';
import { map, withLatestFrom } from 'rxjs/operators';

const source$ = interval(5000);
const secondSource$ = interval(1000);

const example$ = secondSource$.pipe(
  withLatestFrom(source$),
  map(([first, second]) => `Source (1s): ${first} Latest From (5s): ${second}`)
);

example$.subscribe(value => {console.log(value);});
/*
结果： 
Source (1s): 4 Latest From (5s): 0
Source (1s): 5 Latest From (5s): 0
Source (1s): 6 Latest From (5s): 0
Source (1s): 7 Latest From (5s): 0
Source (1s): 8 Latest From (5s): 0
Source (1s): 9 Latest From (5s): 1
*/
```
